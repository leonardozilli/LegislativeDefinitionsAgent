# Portions of this file are covered by the MIT License
# Copyright (c) 2024 Joshua Carroll
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.from pydantic import BaseModel, Field

from pydantic import BaseModel, Field
from typing import Literal, Any

from uuid import uuid4

from langchain_core.messages import BaseMessage, ChatMessage
from langchain_core.runnables import RunnableConfig
from langchain_core.runnables.config import merge_configs
from langchain_core.callbacks import adispatch_custom_event


class CustomData(BaseModel):
    "Custom data being sent by an agent"

    type: str = Field(
        description="The type of custom data, used in dispatch events",
        default="custom_data",
    )
    data: dict[str, Any] = Field(description="The custom data")

    def to_langchain(self) -> ChatMessage:
        return ChatMessage(content=[self.data], role="custom")

    async def adispatch(self, config: RunnableConfig | None = None) -> None:
        dispatch_config = RunnableConfig(
            tags=["custom_data_dispatch"],
        )
        await adispatch_custom_event(
            name=self.type,
            data=self.to_langchain(),
            config=merge_configs(config, dispatch_config),
        )

class Task:
    def __init__(self, task_name: str) -> None:
        self.name = task_name
        self.id = str(uuid4())
        self.state: Literal["new", "running", "complete"] = "new"
        self.result: Literal["success", "error"] | None = None

    async def _generate_and_dispatch_message(self, config: RunnableConfig, data: dict):
        task_data = TaskData(name=self.name, run_id=self.id, state=self.state, data=data)
        if self.result:
            task_data.result = self.result
        task_custom_data = CustomData(
            type=self.name,
            data=task_data.model_dump(),
        )
        await task_custom_data.adispatch(config)
        return task_custom_data.to_langchain()

    async def start(self, config: RunnableConfig, data: dict = {}) -> BaseMessage:
        self.state = "new"
        task_message = await self._generate_and_dispatch_message(config, data)
        return task_message

    async def write_data(self, config: RunnableConfig, data: dict) -> BaseMessage:
        if self.state == "complete":
            raise ValueError("Only incomplete tasks can output data.")
        self.state = "running"
        task_message = await self._generate_and_dispatch_message(config, data)
        return task_message

    async def finish(
        self, result: Literal["success", "error"], config: RunnableConfig, data: dict = {}
    ) -> BaseMessage:
        self.state = "complete"
        self.result = result
        task_message = await self._generate_and_dispatch_message(config, data)
        return task_message

class TaskData(BaseModel):
    name: str | None = Field(
        description="Name of the task.", default=None, examples=["Check input safety"]
    )
    run_id: str = Field(
        description="ID of the task run to pair state updates to.",
        default="",
        examples=["847c6285-8fc9-4560-a83f-4e6285809254"],
    )
    state: Literal["new", "running", "complete"] | None = Field(
        description="Current state of given task instance.",
        default=None,
        examples=["running"],
    )
    result: Literal["success", "error"] | None = Field(
        description="Result of given task instance.",
        default=None,
        examples=["running"],
    )
    data: dict[str, Any] = Field(
        description="Additional data generated by the task.",
        default={},
    )

    def completed(self) -> bool:
        return self.state == "complete"

    def completed_with_error(self) -> bool:
        return self.state == "complete" and self.result == "error"


class TaskDataStatus:
    def __init__(self) -> None:
        import streamlit as st

        self.status = st.status("")
        self.current_task_data: dict[str, TaskData] = {}

    def add_and_draw_task_data(self, task_data: TaskData) -> None:
        status = self.status
        status_str = f"Task **{task_data.name}** "
        match task_data.state:
            case "new":
                status_str += "has :blue[started]. Input:"
            case "running":
                status_str += "wrote:"
            case "complete":
                if task_data.result == "success":
                    status_str += ":green[completed successfully]. Output:"
                else:
                    status_str += ":red[ended with error]. Output:"
        status.write(status_str)
        status.write(task_data.data)
        status.write("---")
        if task_data.name not in self.current_task_data:
            # Status label always shows the last newly started task
            status.update(label=f"""Task: {task_data.name}""")
        self.current_task_data[task_data.name] = task_data
        if all(entry.completed() for entry in self.current_task_data.values()):
            # Status is "error" if any task has errored
            if any(entry.completed_with_error() for entry in self.current_task_data.values()):
                state = "error"
            # Status is "complete" if all tasks have completed successfully
            else:
                state = "complete"
        # Status is "running" until all tasks have completed
        else:
            state = "running"
        status.update(state=state)